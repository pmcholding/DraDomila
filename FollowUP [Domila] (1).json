{
  "name": "FollowUP [Domila]",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 15
            }
          ]
        }
      },
      "id": "93c02fd7-4dde-4d88-9081-52e9266eadf2",
      "name": "Schedule Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        -1104,
        -224
      ]
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "062a7278-7f1b-451f-b10f-5e7b51dd1456",
      "name": "Split In Batches",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        -560,
        -256
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT\n    m.id,\n    m.content,\n    m.created_at,\n    m.message_type,\n    m.conversation_id\nFROM messages m\nWHERE m.conversation_id = {{ $json.conversation_id }}\n  AND m.message_type = 0\nORDER BY m.created_at DESC\nLIMIT 10",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -320,
        -416
      ],
      "id": "dc5d6b76-57c8-40ba-9087-fc80c98720f4",
      "name": "Última Mensagem",
      "credentials": {
        "postgres": {
          "id": "bmC45JpdFCXrM2m0",
          "name": "draidbprod"
        }
      }
    },
    {
      "parameters": {
        "operation": "select",
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "followup_templates",
          "mode": "list",
          "cachedResultName": "followup_templates"
        },
        "where": {
          "values": [
            {
              "column": "chatwoot_account_id",
              "value": "25"
            },
            {
              "column": "ativo",
              "value": "true"
            },
            {
              "column": "followup_name",
              "value": "leads"
            }
          ]
        },
        "sort": {
          "values": [
            {
              "column": "ordem_exibicao"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -336,
        -64
      ],
      "id": "9734cc8a-da70-4e64-afba-76207627afa0",
      "name": "Buscar Templates",
      "credentials": {
        "postgres": {
          "id": "Z1SFFrfXW21Hy6tO",
          "name": "BotNew"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Calcular tempo decorrido e aplicar templates dinâmicos\nconst inputs = $input.all();\nconsole.log(\"Total de inputs:\", inputs.length);\n\n// Dados da conversa do Split In Batches\nconst dadosConversa = $('Split In Batches').item.json;\nconst telefoneConversa = dadosConversa.contact_identifier || dadosConversa.contact_phone || '';\nconst nomeConversa = dadosConversa.contact_name || 'Lead';\n\n// Separar mensagem e templates\nlet ultimaMensagem = null;\nlet followupTemplates = [];\nlet todasMensagens = [];\n\n// Processar inputs para extrair dados\nfor (const input of inputs) {\n  const data = input.json;\n  \n  if (data && data.mensagem_template) {\n    // É um template de follow-up\n    followupTemplates.push(data);\n  } else if (data && data.created_at && data.content !== undefined) {\n    // É uma mensagem do cliente (tabela messages do Chatwoot)\n    todasMensagens.push(data);\n  }\n}\n\n// Encontrar a mensagem mais recente\nif (todasMensagens.length > 0) {\n  // Ordenar por created_at (mais recente primeiro)\n  todasMensagens.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));\n  ultimaMensagem = todasMensagens[0]; // Pegar a mais recente\n  \n  console.log(`Mensagens encontradas: ${todasMensagens.length}`);\n  console.log(`Mensagem mais recente: ID ${ultimaMensagem.id} - ${ultimaMensagem.created_at}`);\n}\n\nconsole.log(\"Templates encontrados:\", followupTemplates.length);\nconsole.log(\"Mensagens encontradas:\", todasMensagens.length);\nconsole.log(\"Mensagem mais recente selecionada:\", ultimaMensagem ? `ID ${ultimaMensagem.id}` : \"Nenhuma\");\n\n// Verificar se temos dados suficientes\nif (!ultimaMensagem || followupTemplates.length === 0) {\n  return [{\n    debug_erro: \"Dados insuficientes\",\n    debug_ultimaMensagem: !!ultimaMensagem,\n    debug_mensagens_encontradas: todasMensagens.length,\n    debug_templates_count: followupTemplates.length,\n    debug_inputs_completos: inputs,\n    debug_estrutura_inputs: inputs.map(input => Object.keys(input.json || {})),\n    debug_todas_mensagens: todasMensagens.map(m => `ID ${m.id} - ${m.created_at}`)\n  }];\n}\n\n// Verificar se a mensagem tem created_at\nif (!ultimaMensagem.created_at) {\n  return [{\n    debug_erro: \"Mensagem sem created_at\",\n    debug_ultimaMensagem: ultimaMensagem\n  }];\n}\n\n// ========== VERIFICAÇÃO SE ESTAMOS EM HORÁRIO ÚTIL ==========\nconst agora = new Date();\nconst ultimaMensagemData = new Date(ultimaMensagem.created_at);\n\nfunction estaEmHorarioUtil(data) {\n  const dia = data.getDay(); // 0=domingo, 1=segunda, ..., 6=sábado\n  const hora = data.getHours();\n  \n  // Fins de semana\n  if (dia === 0 || dia === 6) return false;\n  \n  // Fora do horário 8h-20h\n  if (hora < 8 || hora >= 20) return false;\n  \n  return true;\n}\n\n// ========== SE ESTAMOS FORA DO HORÁRIO, PAUSAR CONTAGEM ==========\nif (!estaEmHorarioUtil(agora)) {\n  // Calcular próximo horário útil\n  const proximoHorarioUtil = new Date(agora);\n  \n  // Se for fim de semana\n  if (agora.getDay() === 0) { // Domingo -> Segunda 8h\n    proximoHorarioUtil.setDate(agora.getDate() + 1);\n    proximoHorarioUtil.setHours(8, 0, 0, 0);\n  } else if (agora.getDay() === 6) { // Sábado -> Segunda 8h\n    proximoHorarioUtil.setDate(agora.getDate() + 2);\n    proximoHorarioUtil.setHours(8, 0, 0, 0);\n  } else {\n    // Dia útil, mas fora do horário\n    if (agora.getHours() < 8) {\n      // Antes das 8h -> 8h do mesmo dia\n      proximoHorarioUtil.setHours(8, 0, 0, 0);\n    } else {\n      // Depois das 20h -> 8h do próximo dia útil\n      proximoHorarioUtil.setDate(agora.getDate() + 1);\n      proximoHorarioUtil.setHours(8, 0, 0, 0);\n      \n      // Se o próximo dia for fim de semana, ir para segunda\n      if (proximoHorarioUtil.getDay() === 6) { // Sábado -> Segunda\n        proximoHorarioUtil.setDate(proximoHorarioUtil.getDate() + 2);\n      } else if (proximoHorarioUtil.getDay() === 0) { // Domingo -> Segunda\n        proximoHorarioUtil.setDate(proximoHorarioUtil.getDate() + 1);\n      }\n    }\n  }\n  \n  // Calcular apenas o tempo útil até agora (sem incluir tempo fora do expediente)\n  const minutosUteisAteAgora = calcularMinutosUteis(ultimaMensagemData, agora);\n  \n  // Construir contexto das mensagens mesmo quando fora do horário\n  let contextMensagens = \"\";\n  const ultimas3Mensagens = todasMensagens.slice(0, 3);\n  \n  if (ultimas3Mensagens.length > 0) {\n    contextMensagens = ultimas3Mensagens\n      .reverse()\n      .map((msg, index) => {\n        const dataFormatada = new Date(msg.created_at).toLocaleString('pt-BR', {timeZone: 'America/Sao_Paulo'});\n        const msgContent = (msg.content || 'Sem mensagem').replace(/\\n/g, ' ');\n        return `Mensagem ${index + 1} (${dataFormatada}):\\nCliente: \"${msgContent}\"`;\n      })\n      .join('\\n\\n');\n  }\n  \n  return [{\n    debug_status: \"⏸️ TEMPO PAUSADO - Fora do horário útil\",\n    debug_diferenca_minutos_uteis: Math.floor(minutosUteisAteAgora),\n    debug_diferenca_minutos_totais: Math.floor((agora - ultimaMensagemData) / (1000 * 60)),\n    debug_agora_utc: agora.toISOString(),\n    debug_agora_brasil: agora.toLocaleString('pt-BR', {timeZone: 'America/Sao_Paulo'}),\n    debug_ultima_brasil: ultimaMensagemData.toLocaleString('pt-BR', {timeZone: 'America/Sao_Paulo'}),\n    debug_proximo_horario_util: proximoHorarioUtil.toLocaleString('pt-BR', {timeZone: 'America/Sao_Paulo'}),\n    debug_horario_atual: `${agora.getHours()}:${agora.getMinutes().toString().padStart(2, '0')}`,\n    debug_dia_semana: ['Domingo', 'Segunda', 'Terça', 'Quarta', 'Quinta', 'Sexta', 'Sábado'][agora.getDay()],\n    debug_expediente: \"8h às 20h (segunda a sexta)\",\n    debug_motivo_pausa: agora.getDay() === 0 || agora.getDay() === 6 ? \"Fim de semana\" : \n                       agora.getHours() < 8 ? \"Antes do expediente\" : \"Após o expediente\",\n    \n    // Dados básicos para não quebrar o fluxo (usando dados da conversa)\n    phone: telefoneConversa,\n    nome: nomeConversa,\n    ultima_mensagem: ultimaMensagem,\n    \n    // NOVO: Contexto das 3 últimas mensagens\n    contexto_mensagens: contextMensagens,\n    total_mensagens_analisadas: ultimas3Mensagens.length,\n    \n    // Templates disponíveis para referência\n    debug_templates_disponiveis: followupTemplates.map(t => `${t.nome_display} (${t.intervalo_min_minutos}-${t.intervalo_max_minutos}min)`)\n  }];\n}\n\n// ========== CÁLCULO DE HORÁRIOS ÚTEIS (APENAS SE ESTIVERMOS EM HORÁRIO ÚTIL) ==========\n\n// Função para calcular minutos úteis entre duas datas\nfunction calcularMinutosUteis(dataInicio, dataFim) {\n  const HORA_INICIO = 8; // 8h\n  const HORA_FIM = 20;   // 20h\n  const MINUTOS_POR_DIA_UTIL = (HORA_FIM - HORA_INICIO) * 60; // 12h * 60min = 720min\n  \n  let inicio = new Date(dataInicio);\n  let fim = new Date(dataFim);\n  let minutosUteis = 0;\n  \n  // Se a data de fim for anterior ao início, retorna 0\n  if (fim <= inicio) return 0;\n  \n  // Ajustar início para próximo horário útil se necessário\n  while (inicio < fim) {\n    const diaInicio = inicio.getDay(); // 0=domingo, 1=segunda, ..., 6=sábado\n    const horaInicio = inicio.getHours();\n    const minutoInicio = inicio.getMinutes();\n    \n    // Pular fins de semana\n    if (diaInicio === 0 || diaInicio === 6) {\n      // Ir para próxima segunda-feira às 8h\n      const diasParaSegunda = diaInicio === 0 ? 1 : 2;\n      inicio.setDate(inicio.getDate() + diasParaSegunda);\n      inicio.setHours(HORA_INICIO, 0, 0, 0);\n      continue;\n    }\n    \n    // Se antes das 8h, ir para 8h do mesmo dia\n    if (horaInicio < HORA_INICIO) {\n      inicio.setHours(HORA_INICIO, 0, 0, 0);\n      continue;\n    }\n    \n    // Se depois das 20h, ir para 8h do próximo dia útil\n    if (horaInicio >= HORA_FIM) {\n      inicio.setDate(inicio.getDate() + 1);\n      inicio.setHours(HORA_INICIO, 0, 0, 0);\n      continue;\n    }\n    \n    // Calcular fim do dia útil atual\n    const fimDiaAtual = new Date(inicio);\n    fimDiaAtual.setHours(HORA_FIM, 0, 0, 0);\n    \n    // Determinar o fim real (menor entre fim do dia útil e data fim)\n    const fimReal = fim < fimDiaAtual ? fim : fimDiaAtual;\n    \n    // Calcular minutos úteis do período atual\n    const minutosNoPeriodo = Math.max(0, (fimReal - inicio) / (1000 * 60));\n    minutosUteis += minutosNoPeriodo;\n    \n    // Avançar para próximo dia útil se necessário\n    if (fimReal === fimDiaAtual && fim > fimDiaAtual) {\n      inicio.setDate(inicio.getDate() + 1);\n      inicio.setHours(HORA_INICIO, 0, 0, 0);\n    } else {\n      break;\n    }\n  }\n  \n  return Math.floor(minutosUteis);\n}\n\n// Função para adicionar minutos úteis a uma data\nfunction adicionarMinutosUteis(dataInicio, minutosParaAdicionar) {\n  const HORA_INICIO = 8; // 8h\n  const HORA_FIM = 20;   // 20h\n  const MINUTOS_POR_DIA_UTIL = (HORA_FIM - HORA_INICIO) * 60; // 720 minutos\n  \n  let dataAtual = new Date(dataInicio);\n  let minutosRestantes = minutosParaAdicionar;\n  \n  // Ajustar para próximo horário útil se necessário\n  while (true) {\n    const diaAtual = dataAtual.getDay();\n    const horaAtual = dataAtual.getHours();\n    \n    // Pular fins de semana\n    if (diaAtual === 0 || diaAtual === 6) {\n      const diasParaSegunda = diaAtual === 0 ? 1 : 2;\n      dataAtual.setDate(dataAtual.getDate() + diasParaSegunda);\n      dataAtual.setHours(HORA_INICIO, 0, 0, 0);\n      continue;\n    }\n    \n    // Se antes das 8h, ir para 8h do mesmo dia\n    if (horaAtual < HORA_INICIO) {\n      dataAtual.setHours(HORA_INICIO, 0, 0, 0);\n      continue;\n    }\n    \n    // Se depois das 20h, ir para 8h do próximo dia útil\n    if (horaAtual >= HORA_FIM) {\n      dataAtual.setDate(dataAtual.getDate() + 1);\n      dataAtual.setHours(HORA_INICIO, 0, 0, 0);\n      continue;\n    }\n    \n    break; // Está em horário útil\n  }\n  \n  // Adicionar os minutos úteis\n  while (minutosRestantes > 0) {\n    const diaAtual = dataAtual.getDay();\n    const horaAtual = dataAtual.getHours();\n    const minutoAtual = dataAtual.getMinutes();\n    \n    // Calcular minutos restantes no dia útil atual\n    const fimDia = new Date(dataAtual);\n    fimDia.setHours(HORA_FIM, 0, 0, 0);\n    const minutosRestantesHoje = (fimDia - dataAtual) / (1000 * 60);\n    \n    if (minutosRestantes <= minutosRestantesHoje) {\n      // Cabe no dia atual\n      dataAtual.setMinutes(dataAtual.getMinutes() + minutosRestantes);\n      break;\n    } else {\n      // Vai para o próximo dia útil\n      minutosRestantes -= minutosRestantesHoje;\n      dataAtual.setDate(dataAtual.getDate() + 1);\n      dataAtual.setHours(HORA_INICIO, 0, 0, 0);\n      \n      // Pular fins de semana\n      while (dataAtual.getDay() === 0 || dataAtual.getDay() === 6) {\n        dataAtual.setDate(dataAtual.getDate() + 1);\n        if (dataAtual.getDay() === 1) { // Segunda-feira\n          dataAtual.setHours(HORA_INICIO, 0, 0, 0);\n        }\n      }\n    }\n  }\n  \n  return dataAtual;\n}\n\n// Calcular diferença em minutos úteis\nconst diferencaMinutos = calcularMinutosUteis(ultimaMensagemData, agora);\n\nconsole.log(`✅ EM HORÁRIO ÚTIL - Diferença: ${diferencaMinutos} minutos úteis`);\n\n// ========== VERIFICAR QUAL TEMPLATE APLICAR ==========\nlet templateAplicavel = null;\nlet statusDisparo = \"\";\nlet proximosDisparos = []; // Declarar aqui para estar disponível em todo o escopo\n\n// Ordenar templates por ordem_exibicao para garantir a sequência correta\nfollowupTemplates.sort((a, b) => a.ordem_exibicao - b.ordem_exibicao);\n\nfor (const template of followupTemplates) {\n  const minMinutos = parseInt(template.intervalo_min_minutos);\n  const maxMinutos = parseInt(template.intervalo_max_minutos);\n  \n  console.log(`Verificando template \"${template.nome_display}\": ${minMinutos}-${maxMinutos} min`);\n  \n  if (diferencaMinutos >= minMinutos && diferencaMinutos <= maxMinutos) {\n    templateAplicavel = template;\n    statusDisparo = `✅ DISPARO ${template.nome_display} - Diferença: ${Math.floor(diferencaMinutos)} min úteis`;\n    console.log(`Template aplicável encontrado: ${template.nome_display}`);\n    break;\n  }\n}\n\n// Calcular próximos templates com data/hora exata (sempre executa)\nlet proximosTemplates = [];\n\nfor (const template of followupTemplates) {\n  const minMinutos = parseInt(template.intervalo_min_minutos);\n  if (diferencaMinutos < minMinutos) {\n    const tempoRestante = Math.floor(minMinutos - diferencaMinutos);\n    \n    // Calcular data/hora exata do disparo\n    const dataDisparo = adicionarMinutosUteis(ultimaMensagemData, minMinutos);\n    \n    const diasSemana = ['Domingo', 'Segunda', 'Terça', 'Quarta', 'Quinta', 'Sexta', 'Sábado'];\n    const diaSemana = diasSemana[dataDisparo.getDay()];\n    const dataFormatada = dataDisparo.toLocaleDateString('pt-BR', {timeZone: 'America/Sao_Paulo'});\n    const horaFormatada = dataDisparo.toLocaleTimeString('pt-BR', { \n      hour: '2-digit', \n      minute: '2-digit',\n      timeZone: 'America/Sao_Paulo'\n    });\n    \n    proximosTemplates.push(`${template.nome_display} em: ${tempoRestante} min úteis`);\n    \n    proximosDisparos.push({\n      template_nome: template.nome_display,\n      minutos_restantes: tempoRestante,\n      data_disparo_utc: dataDisparo.toISOString(),\n      data_disparo_brasil: dataDisparo.toLocaleString('pt-BR', {timeZone: 'America/Sao_Paulo'}),\n      dia_semana: diaSemana,\n      data_formatada: dataFormatada,\n      hora_formatada: horaFormatada,\n      disparo_formatado: `${diaSemana}, ${dataFormatada} às ${horaFormatada}`\n    });\n  }\n}\n\nif (!templateAplicavel) {\n  statusDisparo = `✅ EM HORÁRIO ÚTIL - NENHUM DISPARO - Diferença: ${Math.floor(diferencaMinutos)} min úteis`;\n  statusDisparo += ` | Próximos: ${proximosTemplates.slice(0, 3).join(', ') || 'Nenhum'}`;\n}\n\n// ========== EXTRAIR DADOS DO CONTATO (da conversa, não da mensagem) ==========\nconst telefone = telefoneConversa;\nconst nomeLead = nomeConversa;\n\n// ========== CONSTRUIR CONTEXTO DAS 3 ÚLTIMAS MENSAGENS ==========\nlet contextMensagens = \"\";\nconst ultimas3Mensagens = todasMensagens.slice(0, 3); // Já estão ordenadas (mais recente primeiro)\n\nif (ultimas3Mensagens.length > 0) {\n  contextMensagens = ultimas3Mensagens\n    .reverse() // Inverter para ordem cronológica (mais antiga primeiro)\n    .map((msg, index) => {\n      const dataFormatada = new Date(msg.created_at).toLocaleString('pt-BR', {timeZone: 'America/Sao_Paulo'});\n      const msgContent = (msg.content || 'Sem mensagem').replace(/\\n/g, ' ');\n      return `Mensagem ${index + 1} (${dataFormatada}):\\nCliente: \"${msgContent}\"`;\n    })\n    .join('\\n\\n');\n}\n\n// ========== CONSTRUIR RESULTADO ==========\nconst resultado = {\n  // Dados originais\n  id: ultimaMensagem.id,\n  phone: telefone,\n  nome: nomeLead,\n  \n  // CONTEXTO DAS 3 ÚLTIMAS MENSAGENS\n  contexto_mensagens: contextMensagens,\n  total_mensagens_analisadas: ultimas3Mensagens.length,\n  \n  // CRONOGRAMA DE PRÓXIMOS DISPAROS\n  proximos_disparos: proximosDisparos,\n  \n  // INFORMAÇÕES DE DEBUG\n  debug_status: statusDisparo,\n  debug_diferenca_minutos_uteis: Math.floor(diferencaMinutos),\n  debug_diferenca_minutos_totais: Math.floor((agora - ultimaMensagemData) / (1000 * 60)),\n  debug_ultima_mensagem_original: ultimaMensagem.created_at,\n  debug_agora_utc: agora.toISOString(),\n  debug_agora_brasil: agora.toLocaleString('pt-BR', {timeZone: 'America/Sao_Paulo'}),\n  debug_ultima_brasil: ultimaMensagemData.toLocaleString('pt-BR', {timeZone: 'America/Sao_Paulo'}),\n  debug_horario_util: \"8h às 20h (segunda a sexta)\",\n  debug_templates_disponiveis: followupTemplates.map(t => `${t.nome_display} (${t.intervalo_min_minutos}-${t.intervalo_max_minutos}min)`),\n  debug_content: ultimaMensagem.content,\n  debug_em_horario_util: true,\n  debug_mensagens_processadas: todasMensagens.map(m => `ID ${m.id} - ${m.created_at}`),\n  ultima_mensagem: ultimaMensagem\n};\n\n// Adicionar dados do follow-up se houver template aplicável\nif (templateAplicavel) {\n  // Calcular quando este template deveria ser disparado\n  const dataDisparoAtual = adicionarMinutosUteis(ultimaMensagemData, parseInt(templateAplicavel.intervalo_min_minutos));\n  \n  const diasSemana = ['Domingo', 'Segunda', 'Terça', 'Quarta', 'Quinta', 'Sexta', 'Sábado'];\n  const diaSemana = diasSemana[dataDisparoAtual.getDay()];\n  const dataFormatada = dataDisparoAtual.toLocaleDateString('pt-BR', {timeZone: 'America/Sao_Paulo'});\n  const horaFormatada = dataDisparoAtual.toLocaleTimeString('pt-BR', { \n    hour: '2-digit', \n    minute: '2-digit',\n    timeZone: 'America/Sao_Paulo'\n  });\n  \n  resultado.tipo_followup = templateAplicavel.id;\n  resultado.template_nome = templateAplicavel.nome_display;\n  resultado.mensagem_template = templateAplicavel.mensagem_template;\n  resultado.telefone = telefone;\n  resultado.nome_lead = nomeLead;\n  resultado.intervalo_aplicado = `${templateAplicavel.intervalo_min_minutos}-${templateAplicavel.intervalo_max_minutos} min úteis`;\n  resultado.disparo_programado_para = `${diaSemana}, ${dataFormatada} às ${horaFormatada}`;\n  resultado.disparo_data_completa = dataDisparoAtual.toLocaleString('pt-BR', {timeZone: 'America/Sao_Paulo'});\n}\n\nreturn [resultado];"
      },
      "id": "64251c78-d85c-4445-bd07-f17f1a5c536b",
      "name": "Calcular Tempo",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        48,
        -128
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "needs-followup",
              "leftValue": "={{ $json.tipo_followup }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "exists",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "e0778286-0133-461c-ad87-0cc64974eef2",
      "name": "IF Needs Follow-up",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        240,
        -96
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=# Prompt Atualizado para a AI Clara - Clínica Dra. Domila Mattos\n\n```text\nVocê é uma assistente virtual da Clínica da Dra. Domila Mattos.\n\nCONTEXTO: Você está enviando uma mensagem de follow-up para {{ $json.nome_lead }} que parou de responder durante a conversa sobre agendamento de consulta médica.\n\nINFORMAÇÕES DO FOLLOW-UP:\n- Template: {{ $json.template_nome }}\n- Telefone: {{ $json.telefone }}\n- Intervalo aplicado: {{ $json.intervalo_aplicado }}\n\nHISTÓRICO DA CONVERSA:\nAnalise todo o histórico de mensagens disponível na memória para entender:\n1. Qual tipo de dor/problema ortopédico o paciente mencionou\n2. Qual era o interesse específico na consulta\n3. Se demonstrou interesse em agendamento\n4. Suas principais preocupações (preço, disponibilidade, etc.)\n5. Em que ponto da conversa parou de responder\n\nMENSAGEM BASE PARA PERSONALIZAR:\n{{ $json.mensagem_template }}\n\nINSTRUÇÕES PARA PERSONALIZAÇÃO:\n1. **Mantenha o tom profissional e empático** adequado para área médica\n2. **Use linguagem acolhedora** que transmita cuidado e confiança\n3. **Integre sutilmente** o contexto do histórico DENTRO da mensagem base\n4. **Adicione contexto específico** quando relevante: \n   - Tipo de dor/problema mencionado\n   - Urgência do caso\n   - Preocupações demonstradas\n5. **Seja natural** - o contexto deve fluir organicamente\n6. **Não force** referências se não fizerem sentido\n7. **Se não houver contexto suficiente**, use a mensagem base EXATAMENTE como está\n\nTOM E LINGUAGEM:\n- Profissional mas humano\n- Empático e acolhedor\n- Focado na saúde e bem-estar\n- Respeitoso com o tempo do paciente\n- Incentive o agendamento de forma natural\n\nREGRA IMPORTANTE: Se o histórico não fornecer contexto médico relevante, use exatamente a mensagem base original. Não invente sintomas ou informações médicas.\n\nResponda apenas com a mensagem personalizada, sem explicações adicionais.\n```",
        "options": {}
      },
      "id": "2329de03-11a8-4e85-90ab-09ca57a17620",
      "name": "AI Clara",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.6,
      "position": [
        1088,
        -400
      ]
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4.1-mini",
          "mode": "list",
          "cachedResultName": "gpt-4.1-mini"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        1008,
        -160
      ],
      "id": "5181c367-2498-4b2e-a72f-5471059b5d7b",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "kt7BIIhS1MTQeq8c",
          "name": "OpenAi ProFort"
        }
      }
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $json.phone }}",
        "contextWindowLength": 10
      },
      "type": "@n8n/n8n-nodes-langchain.memoryPostgresChat",
      "typeVersion": 1.3,
      "position": [
        1232,
        -160
      ],
      "id": "658a8e27-8809-4ff5-8325-f38742228f70",
      "name": "Postgres Chat Memory",
      "credentials": {
        "postgres": {
          "id": "Z1SFFrfXW21Hy6tO",
          "name": "BotNew"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Lista de conversas sem assignee (assignee_id = NULL) \n-- incluindo o identifier dos contatos relacionados\n\nSELECT \n    c.id as conversation_id,\n    c.uuid as conversation_uuid,\n    c.display_id,\n    c.identifier as conversation_identifier,\n    c.status,\n    c.inbox_id,\n    c.created_at as conversation_created_at,\n    c.updated_at as conversation_updated_at,\n    c.last_activity_at,\n    c.priority,\n    -- Dados do contato\n    ct.id as contact_id,\n    ct.identifier as contact_identifier,\n    ct.name as contact_name,\n    ct.email as contact_email,\n    ct.phone_number as contact_phone,\n    ct.location as contact_location\nFROM conversations c\nLEFT JOIN contacts ct ON c.contact_id = ct.id\nWHERE c.account_id = 25\n  AND c.cached_label_list LIKE '%followup%'\n  AND c.updated_at >= CURRENT_DATE - INTERVAL '15 days'\n  AND (ct.identifier LIKE '%@s.whatsapp.net' or \n  ct.identifier LIKE '%lid%')\nORDER BY c.last_activity_at DESC NULLS LAST;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -816,
        -224
      ],
      "id": "4eda2845-a283-429c-9eff-cbdb966aaa47",
      "name": "Buscar Conversas",
      "credentials": {
        "postgres": {
          "id": "bmC45JpdFCXrM2m0",
          "name": "draidbprod"
        }
      }
    },
    {
      "parameters": {
        "mode": "append"
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [
        -144,
        -144
      ],
      "id": "aa498cdf-d242-4b47-9601-6e5c088d5cd7",
      "name": "Merge"
    },
    {
      "parameters": {
        "inputText": "={{ $('Última Mensagem').all().map((msg, index) => `Mensagem ${index + 1} (${new Date(msg.json.created_at).toLocaleString('pt-BR')}):\nCliente: \"${(msg.json.content || 'Sem mensagem').replace(/\\n/g, ' ')}\"`).reverse().join('\\n\\n') }}",
        "categories": {
          "categories": [
            {
              "category": "encerrada",
              "description": "Houve um desfecho da conversa ou agendamento de uma consulta e o agente de IA se despediu"
            },
            {
              "category": "sem_resposta",
              "description": "=Se o cliente não respondeu mais as mensagens do agente - mensagem do paciente vazia"
            },
            {
              "category": "pendente_resposta",
              "description": "=A conversa está pendente devido a uma informação que o paciente ficou de fornecer ou confirmar."
            }
          ]
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.textClassifier",
      "typeVersion": 1,
      "position": [
        432,
        -336
      ],
      "id": "603e9935-d69e-40a7-810b-b5ad1a5c3d56",
      "name": "Text Classifier1"
    },
    {
      "parameters": {
        "model": "gpt-4.1-mini",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1,
      "position": [
        480,
        -128
      ],
      "id": "6126d597-4ee1-490c-9d64-b0c974a3b581",
      "name": "OpenAI Chat Model5",
      "credentials": {
        "openAiApi": {
          "id": "kt7BIIhS1MTQeq8c",
          "name": "OpenAi ProFort"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Query para remover o label \"followup\" de uma conversation específica\n-- Substitua CONVERSATION_ID pelo ID da conversa desejada\n\nUPDATE conversations \nSET cached_label_list = CASE \n    -- Se cached_label_list está NULL ou vazio, não faz nada\n    WHEN cached_label_list IS NULL OR cached_label_list = '' THEN cached_label_list\n    -- Se \"followup\" é o único label, limpa o campo\n    WHEN LOWER(TRIM(cached_label_list)) = 'followup' THEN ''\n    -- Remove \"followup,\" do início (followup,outros)\n    WHEN cached_label_list ILIKE 'followup,%' THEN \n        SUBSTRING(cached_label_list FROM LENGTH('followup,') + 1)\n    -- Remove \",followup\" do final (outros,followup)  \n    WHEN cached_label_list ILIKE '%,followup' THEN \n        SUBSTRING(cached_label_list FROM 1 FOR LENGTH(cached_label_list) - LENGTH(',followup'))\n    -- Remove \",followup,\" do meio (outros,followup,mais)\n    WHEN cached_label_list ILIKE '%,followup,%' THEN \n        REPLACE(cached_label_list, ',followup,', ',')\n    -- Se não encontrou \"followup\", mantém como está\n    ELSE cached_label_list\nEND,\nupdated_at = CURRENT_TIMESTAMP\nWHERE id = {{ $('Split In Batches').last().json.conversation_id }} -- Substituir pelo ID da conversa\n  AND account_id = 25       -- Garantir que é da conta correta\n  AND cached_label_list ILIKE '%followup%'; -- Só atualiza se contém \"followup\"\n\n-- Exemplo de uso:\n-- UPDATE conversations \n-- SET cached_label_list = CASE \n--     WHEN cached_label_list IS NULL OR cached_label_list = '' THEN cached_label_list\n--     WHEN LOWER(TRIM(cached_label_list)) = 'followup' THEN ''\n--     WHEN cached_label_list ILIKE 'followup,%' THEN \n--         SUBSTRING(cached_label_list FROM LENGTH('followup,') + 1)\n--     WHEN cached_label_list ILIKE '%,followup' THEN \n--         SUBSTRING(cached_label_list FROM 1 FOR LENGTH(cached_label_list) - LENGTH(',followup'))\n--     WHEN cached_label_list ILIKE '%,followup,%' THEN \n--         REPLACE(cached_label_list, ',followup,', ',')\n--     ELSE cached_label_list\n-- END,\n-- updated_at = CURRENT_TIMESTAMP\n-- WHERE id = 12345\n--   AND account_id = 25\n--   AND cached_label_list ILIKE '%followup%';",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        784,
        -608
      ],
      "id": "5ca38b89-8b9a-4cda-8007-f040dbc2ed37",
      "name": "Atribuir inativo",
      "credentials": {
        "postgres": {
          "id": "bmC45JpdFCXrM2m0",
          "name": "draidbprod"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://wpp2.doutorai.com.br/message/sendText/DraDomila",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "15433788D231-492B-8CE4-D5363B7A250F"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n    \"number\": \"{{ $('Calcular Tempo').item.json.telefone }}\",\n      \"text\": {{ JSON.stringify( $('AI Clara').item.json.output) }},\n    \"options\": {\n      \"delay\": 1000,\n      \"presence\": \"composing\",\n      \"linkPreview\": false\n    }\n  } ",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1584,
        -160
      ],
      "id": "6d11d57a-dff2-40e6-834f-937bb5dcdbea",
      "name": "HTTP Request3",
      "alwaysOutputData": false,
      "onError": "continueRegularOutput"
    }
  ],
  "pinData": {
    "Schedule Trigger": [
      {
        "json": {
          "timestamp": "2026-01-12T13:15:08.010-03:00",
          "Readable date": "January 12th 2026, 1:15:08 pm",
          "Readable time": "1:15:08 pm",
          "Day of week": "Monday",
          "Year": "2026",
          "Month": "January",
          "Day of month": "12",
          "Hour": "13",
          "Minute": "15",
          "Second": "08",
          "Timezone": "America/Sao_Paulo (UTC-03:00)"
        },
        "pairedItem": {
          "item": 0
        }
      }
    ]
  },
  "connections": {
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Buscar Conversas",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split In Batches": {
      "main": [
        [],
        [
          {
            "node": "Última Mensagem",
            "type": "main",
            "index": 0
          },
          {
            "node": "Buscar Templates",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Última Mensagem": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Buscar Templates": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Calcular Tempo": {
      "main": [
        [
          {
            "node": "IF Needs Follow-up",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Needs Follow-up": {
      "main": [
        [
          {
            "node": "Text Classifier1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Split In Batches",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Clara": {
      "main": [
        [
          {
            "node": "HTTP Request3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Clara",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Postgres Chat Memory": {
      "ai_memory": [
        [
          {
            "node": "AI Clara",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Buscar Conversas": {
      "main": [
        [
          {
            "node": "Split In Batches",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Calcular Tempo",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model5": {
      "ai_languageModel": [
        [
          {
            "node": "Text Classifier1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Text Classifier1": {
      "main": [
        [
          {
            "node": "Atribuir inativo",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "AI Clara",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "AI Clara",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Atribuir inativo": {
      "main": [
        [
          {
            "node": "Split In Batches",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request3": {
      "main": [
        [
          {
            "node": "Split In Batches",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "1a70f8f6-fe6b-4d5d-a0ce-482f02889d08",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "0dff2809c326d67264ac89b11c62a81c0e33c81a110b2979fd152608e157400d"
  },
  "id": "XGE4uQ6xT2gKEe4K",
  "tags": []
}